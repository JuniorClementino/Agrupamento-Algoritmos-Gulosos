let PriorityQueue = require('priority-queue');  // --- Priority queue - from library: https://www.npmjs.com/package/js-priority-queue
let UnionFind = require('union-find');          // --- Union-find structure
let Utils = require('utils');                       // --- 

exports.run = function(graph, k){

    console.log("--- Running Prim");

    // --- Saves some stats
    let benchmark = {};
    benchmark.primExecutionStart = Date.now();

    // --- Defines a priority queue 
    let compareNumbers = function(edge1, edge2) { return edge1.d - edge2.d; };      // --- Comparison function used by priority queue
    let priorityQueue = new PriorityQueue({ comparator: compareNumbers});
    
    // --- Defines array to mark explored nodes and sets all values to false
    let exploredNodes = [];
    for(let i = 0; i < graph.nodeCount; i++)    exploredNodes[i] = false; 
    let unexploredNodesCount = graph.nodeCount; 

    // --- Selects first node        
    let actualNode = 0;    
    let actualEdge = null; 
    
    // --- While there are still unexplored nodes
    while(unexploredNodesCount > 0) {

        // --- If the actualNode wasn't explored yet
        if(!exploredNodes[actualNode]){

            // --- Get list of edges that are connected to actualNode from the adjacencyMatrix
            let connectedEdges = graph.adjacencyMatrix[actualNode];
            
            // --- For each edge going from actualNode to an arbitrary node vx
            for(vx = 0; vx < graph.nodeCount; vx++){
                
                // --- If vx is not the actual node and vx wasn't explored yet
                if(actualNode != vx && !exploredNodes[vx]){

                    // --- Put the edge on the queue
                    priorityQueue.queue({
                        v1: actualNode,
                        v2: vx,
                        d: connectedEdges[vx]                  
                    });                      // --- O(log(n)) - hopefully, according to js-priority-queue documentation                
                }
            }

            // --- Mark actualNode as explored
            exploredNodes[actualNode] = true;
            unexploredNodesCount--;
            
            // --- Push the actual edge to the minimum spanning tree          
            if(actualEdge) graph.mstEdgeList.push(actualEdge);                           
        }

        // --- Gets new node to explore from the queue
        actualEdge = priorityQueue.dequeue();
        actualNode = actualEdge.v2;
    } 
    
    // --- Some more stats
    benchmark.primExecutionEnd = Date.now();
    benchmark.primExecutionTime = benchmark.primExecutionEnd - benchmark.primExecutionStart;      

    // --- Since prim algorithm results in a minimum spanning tree,
    //      we need to remove k-1 edges from mst and generate the clusters
    let clusters = clusterize(graph, k);

    // --- More and mora stats...
    benchmark.primGroupEnd = Date.now();
    benchmark.primGroupTime = benchmark.primGroupEnd - benchmark.primExecutionEnd;    


    console.log("    Prim Run Time", benchmark.primExecutionTime, "ms");  
    console.log("    Prim Cluster Time", benchmark.primGroupTime, "ms\n");  

    return clusters;
}


function clusterize(graph, k){

    // --- Sort Minimum Spanning tree by edges lenght     
    graph.mstEdgeList.sort(function(a, b) {
        return b.d - a.d;
    });

    // --- In order to get k groups, removes k-1 first elements from array
    let disconectedGraph = graph.mstEdgeList.slice(k-1);
      
    // --- Creates Union-find structure to group nodes
    let unionFind = new UnionFind.unionFind(graph.nodeCount);  
        
    // --- For each edge remaining in disconectedGraph
    for(i = 0; i < disconectedGraph.length; i++){
        let v1 = disconectedGraph[i].v1;
        let v2 = disconectedGraph[i].v2;        

        // --- Groups nodes in order to get clusters
        unionFind.union(v1, v2);
    }

    // --- Prints node and node group
    return Utils.formatClusterIndexes(unionFind);
}